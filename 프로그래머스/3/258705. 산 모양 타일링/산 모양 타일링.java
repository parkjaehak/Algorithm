import java.util.*;

class Solution {
    public int solution(int n, int[] tops) {
        final int MOD = 10007;

        // 역삼각형에 주목
        // 1. 위쪽 마름모 (위쪽 정삼각형 여부)
        // 2. 왼쪽 마름모 (이전에 3번을 적용한 경우, 사용불가)
        // 3. 오른쪽 마름모
        // 4. 정삼각형

        // a[k] : k번째까지 덮은 경우의 수, k번째 3번 적용 
        // b[k] : k번째까지 덮은 경우의 수, k번째 1,2,4번 적용

        // 'k'번째 위에 정삼각형이 있는 경우
        // a[k]는 항상 3번 방법을 사용할 수 있다. (오른쪽 새 삼각형을 사용하기 때문)
        // -> a[k] = a[k-1] + b[k-1] // 한 가지 방법으로만 채우기 때문에 계수가 없다
        // b[k]는 이전에 3번 방법을 썼으면(a[k]), 1,4번 적용 가능
        // 이전에 3번 방법을 쓰지 않았으면(b[k]), 1,2,4 적용이 가능
        // -> b[k] = 2 * a[k-1] + 3 * b[k-1]
        
        // 'k'번째 위에 정삼각형이 없는 경우
        // a[k]는 동일하다
        // -> a[k] = a[k-1] + b[k-1] // 어차피 1번 방법을 사용하지 않음
        // b[k]는 1번 방법을 사용할 수 없으므로 계수에서 -1씩 해준다
        // -> b[k] = a[k-1] + 2 * b[k-1]

        int[] a = new int[n + 1];
        int[] b = new int[n + 1];
        a[1] = 1;
        b[1] = 2 + tops[0]; // 정삼각형이 있으면 초기에 3가지 방법, 아니면 2가지

        for(int i = 2; i <= n; i++) {
            // 1. 정삼각형이 있는 경우
            if(tops[i - 1] == 1) {
                a[i] = (a[i-1] + b[i-1]) % MOD;
                b[i] = (2 * a[i-1] + 3 * b[i-1]) % MOD;
            }
            // 2. 정삼각형이 없는 경우
            else {
                a[i] = (a[i-1] + b[i-1]) % MOD;
                b[i] = (a[i-1] + 2 * b[i-1]) % MOD;
            }
        }

        return (a[n] + b[n]) % MOD;
    }
}
